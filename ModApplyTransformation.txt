Attribute VB_Name = "ModTRANSFORMATION"
Public inverse_N As Variant
Public Transpose_A As Variant
Public kVector As Variant
Public lVector As Variant
Public polynomialDegree As Single
Public parameters As Single
Public apriori_s As Double
Public sigma_aposteriori As Double
Public degreesOfFreedom As Single
Public numberOfPoints As Integer
Public b As Variant
Public xEstimation As Variant

' points are of type: ' 1) 36.1565464, 28.545865156
Function xForIndexFromListBox(i As Integer, listBox As ListBox) As Long
    Dim x As Long
    Dim itemText As String
    Dim xString As String
    Dim startPos As Integer, commaPos As Integer
    itemText = ListBox.List(i)
    startPos = InStr(itemText, ")")
    commaPos = InStr(itemText, ",")
    xString = VBA.Mid(itemText, startPos + 1, commaPos - 3)
    x = Val(xString)
End Function

Function yForIndexFromListBox(i As Integer, listBox As ListBox) As Long
    Dim y As Long
    Dim itemText As String
    Dim yString As String
    Dim startPos As Integer, commaPos As Integer
    itemText = ListBox.List(i)
    commaPos = InStr(itemText, ",")
    yString = VBA.Mid(itemText, commaPos + 1)
    y = Val(yString)
End Function

Sub transformation(polynomialDegree As Single, numberOfPoints As Integer, basePointListBox As ListBox, ListBox2 As ListBox)

    degreesOfFreedom = 2 * numberOfPoints - 2 
    If degreesOfFreedom < 0 Then
        MsgBox "Solution is not possible."
    End If


Dim xBasePoint As Single
Dim ynumb As Single
Dim x As String
Dim y As String

Dim xReferencePoint As Single
Dim yReferencePoint As Single
Dim Xpr
Dim Ypr
Dim k As Single
Dim l As Single

'dhlwsh pinakwn A kai b
ReDim b(1 To 2 * numberOfPoints)

ReDim xvect(0 To numberOfPoints-1) As Variant
ReDim yvect(0 To numberOfPoints-1) As Variant


' Populates k and l vectors. These vectors contain the powers 
' of each parameter of the polynomial (or of the paramters of the X, Y equations)
ReDim kVector(0 To numberOfPoints-1)
ReDim lVector(0 To numberOfPoints-1)
If index = "Bilinear" Then 'GIA DIGRAMMIKO
    kVector = Array(0, 1, 0, 1)
    lVector = Array(0, 0, 1, 1)
Else
    For k = 0 To polynomialDegree
        For l = 0 To k
            kVector(k) = k - l
            lVector(k) = l
        Next l
    Next k
End If


'dhmioyrgei 2 dianysmata me tis yimes twn xi kai yi
'gia ton algori8mo twn stoixeiwn toy A

For i = 0 To basePointListBox.ListCount - 1
    ' get x, y of base point
    xBasePoint = xForIndexFromListBox(i, basePointListBox)
    yBasePoint  = yForIndexFromListBox(i, basePointListBox)

    ' get x, y of reference point
    xReferencePoint = xForIndexFromListBox(i, referencePointListBox)
    yReferencePoint = yForIndexFromListBox(i, referencePointListBox)

    'CREATE b
    b(i) = xReferencePoint
    b(i + n) = yReferencePoint

    'CREATE A
    xvect(i) = xBasePoint
    yvect(i) = yBasePoint
Next i

' Populates Design Matrix A
ReDim A(0 To 2 * numberOfPoints-1, 0 To 2 * numberOfPoints-1) As Variant
Call DesignMatrixA(index, numberOfPoints, A)

' Creates weight matrix P. The matrix P is 2nx2n dimensioned,
' where n is the number of the observations (the selected pairs of points).
' As long as c^2 is unknown, matrix P is equal to the identity matrix I'
ReDim P(0 To 2 * numberOfPoints-1, 0 To 2 * numberOfPoints-1) As Variant
P = identityMatrix(2 * numberOfPoints)

'transpose design matrix A
ReDim Transpose_A(1 To 2 * numberOfPoints, 1 To 2 * n) As Variant
Transpose_A = transposeMatrix(A)

'Calculates the product [A]*[A-1] which must be always equal to the Singular Matrix [I]
'The same result must also come up for the product: [A-1]*[A]=[I]
'You can try it using: Matrix_Mult(k, m) = Matrix_Mult(k, m) + Inverse_Matrix(L, m) * Matrix_A(k, L)

' ATP is the product matrix of the multiplication of 
' the transpose design matrix (A) with weight matrix P 
' (AT*P)
ReDim ATP(1 To 2 * numberOfPoints, 1 To 2 * n)
ATP = multiplyMatrices(Transpose_A, P)


' Normal equations matrix is the product of ((Transpose_A * P) * A)
' N = (Transpose_A * P) * A
ReDim Nmat(1 To 2 * numberOfPoints, 1 To 2 * numberOfPoints)
Nmat = multiplyMatrices(ATP, A)


' Normal equations vector u which is necessary for the final estimation of 
' the unknown transformation parameters is given by: ((Transpose_A * P) * b)
' u = ((Transpose_A * P) * b)
ReDim u(1 To 2 * numberOfPoints) As Variant
u = multiplyMatrices(ATP, b)


ReDim inverse_N(0 To 2 * numberOfPoints-1, 0 To 2 * numberOfPoints-1) As Variant
Call inverseMatrix(numberOfPoints, Nmat)


'typwnei ton xEstimation (ektimiseis parametrwn)
ReDim xEstimation(1 To 2 * numberOfPoints)
For k = 1 To 2 * numberOfPoints
        For l = 1 To 2 * numberOfPoints
            xEstimation(k) = xEstimation(k) + inverse_N(k, l) * u(l)
        Next l
Next k

ReDim AX_mat(1 To 2 * n)
For k = 1 To 2 * n
        For l = 1 To 2 * numberOfPoints
            AX_mat(k) = AX_mat(k) + A(k, l) * xEstimation(l)
        Next l
Next k

ReDim v(1 To 2 * n)
For i = 1 To 2 * n
    v(i) = b(i) - AX_mat(i)
Next i

If degreesOfFreedom = 0 Then
MsgBox "Solution without least square method application."
Else
'Dim sigma_aposteriori As Double
For i = 1 To 2 * n
  stoixeio = v(i) ^ 2
  Sstoixeio = Sstoixeio + stoixeio
Next i
sigma_aposteriori = Sstoixeio / degreesOfFreedom
F_test = sigma_aposteriori / apriori_s
'MsgBox F_test

Call FTEST(degreesOfFreedom, F_test)
End If
End If

Call residual(xvect, yvect, xEstimation, n)

End Sub

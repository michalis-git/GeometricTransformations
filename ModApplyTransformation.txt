Attribute VB_Name = "ModTRANSFORMATION"
Public inverse_N As Variant
Public Transpose_A As Variant
Public kVector As Variant
Public lVector As Variant
Public polynomialDegree As Single
Public parameters As Single
Public apriori_s As Double
Public sigma_aposteriori As Double
Public degreesOfFreedom As Single
Public numberOfPoints As Integer
Public b As Variant
Public xekt As Variant

' points are of type: ' 1) 36.1565464, 28.545865156
Function xForIndexFromListBox(i As Integer, listBox As ListBox) As Long
    Dim x As Long
    Dim itemText As String
    Dim xString As String
    Dim startPos As Integer, commaPos As Integer
    itemText = ListBox.List(i)
    startPos = InStr(itemText, ")")
    commaPos = InStr(itemText, ",")
    xString = VBA.Mid(itemText, startPos + 1, commaPos - 3)
    x = Val(xString)
End Function

Function yForIndexFromListBox(i As Integer, listBox As ListBox) As Long
    Dim y As Long
    Dim itemText As String
    Dim yString As String
    Dim startPos As Integer, commaPos As Integer
    itemText = ListBox.List(i)
    commaPos = InStr(itemText, ",")
    yString = VBA.Mid(itemText, commaPos + 1)
    y = Val(yString)
End Function

Sub transformation(polynomialDegree As Single, numberOfPoints As Integer, basePointListBox As ListBox, ListBox2 As ListBox)

    degreesOfFreedom = 2 * numberOfPoints - 2 
    If degreesOfFreedom < 0 Then
        MsgBox "Solution is not possible."
    End If


Dim xBasePoint As Single
Dim ynumb As Single
Dim x As String
Dim y As String

Dim xReferencePoint As Single
Dim yReferencePoint As Single
Dim Xpr
Dim Ypr
Dim k As Single
Dim l As Single

'dhlwsh pinakwn A kai b
ReDim b(1 To 2 * numberOfPoints)

ReDim xvect(0 To numberOfPoints-1) As Variant
ReDim yvect(0 To numberOfPoints-1) As Variant


' Populates k and l vectors. These vectors contain the powers 
' of each parameter of the polynomial (or of the paramters of the X, Y equations)
ReDim kVector(0 To numberOfPoints-1)
ReDim lVector(0 To numberOfPoints-1)
If index = "Bilinear" Then 'GIA DIGRAMMIKO
    kVector = Array(0, 1, 0, 1)
    lVector = Array(0, 0, 1, 1)
Else
    For k = 0 To polynomialDegree
        For l = 0 To k
            kVector(k) = k - l
            lVector(k) = l
        Next l
    Next k
End If


'dhmioyrgei 2 dianysmata me tis yimes twn xi kai yi
'gia ton algori8mo twn stoixeiwn toy A

For i = 0 To basePointListBox.ListCount - 1
    ' get x, y of base point
    xBasePoint = xForIndexFromListBox(i, basePointListBox)
    yBasePoint  = yForIndexFromListBox(i, basePointListBox)

    ' get x, y of reference point
    xReferencePoint = xForIndexFromListBox(i, referencePointListBox)
    yReferencePoint = yForIndexFromListBox(i, referencePointListBox)

    'CREATE b
    b(i) = xReferencePoint
    b(i + n) = yReferencePoint

    'CREATE A
    xvect(i) = xBasePoint
    yvect(i) = yBasePoint
Next i

' Populates Design Matrix A
ReDim A(0 To 2 * numberOfPoints-1, 0 To 2 * numberOfPoints-1) As Variant
Call DesignMatrixA(index, numberOfPoints, A)

' Creates weight matrix P. The matrix P is 2nx2n dimensioned,
' where n is the number of the observations (the selected pairs of points).
' As long as c^2 is unknown, matrix P is equal to the identity matrix I'
ReDim P(0 To 2 * numberOfPoints-1, 0 To 2 * numberOfPoints-1) As Variant
For i = 0 To 2 * numberOfPoints-1
    For j = 0 To 2 * numberOfPoints-1
        If i = j Then
            P(i, j) = 1
        Else
            P(i, j) = 0
        End If
    Next j
Next i

'TRANSPOSE MATRIX
ReDim Transpose_A(1 To 2 * numberOfPoints, 1 To 2 * n) As Variant
Call TransposeMatrix(numberOfPoints, A, n)

'Calculates the product [A]*[A-1] which must be always equal to the Singular Matrix [I]
'The same result must also come up for the product: [A-1]*[A]=[I]
'You can try it using: Matrix_Mult(k, m) = Matrix_Mult(k, m) + Inverse_Matrix(L, m) * Matrix_A(k, L)

' ATP is the product matrix of the multiplication of 
' the transpose design matrix (A) with weight matrix P 
' (AT*P)
ReDim ATP(1 To 2 * numberOfPoints, 1 To 2 * n)
For k = 1 To 2 * numberOfPoints
    For m = 1 To 2 * n
        ATP(k, m) = ATP(k, m) + Transpose_A(k, m) * P(m, m)
    Next m
Next k


'PINAKES KANONIKWN E3ISWSEWN (N KAI u)
'N = TRANSPOSE_A * P * A
ReDim Nmat(1 To 2 * numberOfPoints, 1 To 2 * numberOfPoints)
For k = 1 To 2 * numberOfPoints
    For m = 1 To 2 * numberOfPoints
        For l = 1 To 2 * n
            Nmat(k, m) = Nmat(k, m) + ATP(k, l) * A(l, m)
        Next l
    Next m
Next k

ReDim u(1 To 2 * numberOfPoints) As Variant
For k = 1 To 2 * numberOfPoints
        For l = 1 To 2 * n
            u(k) = u(k) + ATP(k, l) * b(l)
        Next l
Next k

ReDim inverse_N(0 To 2 * numberOfPoints-1, 0 To 2 * numberOfPoints-1) As Variant
Call Inverse_Table(numberOfPoints, Nmat) ', inverse_N)


'typwnei ton xekt (ektimiseis parametrwn)
ReDim xekt(1 To 2 * numberOfPoints)
For k = 1 To 2 * numberOfPoints
        For l = 1 To 2 * numberOfPoints
            xekt(k) = xekt(k) + inverse_N(k, l) * u(l)
        Next l
Next k

ReDim AX_mat(1 To 2 * n)
For k = 1 To 2 * n
        For l = 1 To 2 * numberOfPoints
            AX_mat(k) = AX_mat(k) + A(k, l) * xekt(l)
        Next l
Next k

ReDim v(1 To 2 * n)
For i = 1 To 2 * n
    v(i) = b(i) - AX_mat(i)
Next i

If degreesOfFreedom = 0 Then
MsgBox "Solution without least square method application."
Else
'Dim sigma_aposteriori As Double
For i = 1 To 2 * n
  stoixeio = v(i) ^ 2
  Sstoixeio = Sstoixeio + stoixeio
Next i
sigma_aposteriori = Sstoixeio / degreesOfFreedom
F_test = sigma_aposteriori / apriori_s
'MsgBox F_test

Call FTEST(degreesOfFreedom, F_test)
End If
End If

Call residual(xvect, yvect, xekt, n)

End Sub

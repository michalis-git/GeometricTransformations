Attribute VB_Name = "ModTRANSFORMATION"
Public inverse_N As Variant
Public Transpose_A As Variant
Public kVector As Variant
Public lVector As Variant
Public polynomialDegree As Single
Public parameters As Single
Public apriori_s As Double
Public sigma_aposteriori As Double
Public degreesOfFreedom As Single
Public numberOfPoints As Integer
Public b As Variant
Public xekt As Variant

' points are of type: ' 1) 36.1565464, 28.545865156
Function xForIndexFromListBox(i As Integer, listBox As ListBox) As Long
    Dim x As Long
    Dim itemText As String
    Dim xString As String
    Dim startPos As Integer, commaPos As Integer
    itemText = ListBox.List(i)
    startPos = InStr(itemText, ")")
    commaPos = InStr(itemText, ",")
    xString = VBA.Mid(itemText, startPos + 1, commaPos - 3)
    x = Val(xString)
End Function

Function yForIndexFromListBox(i As Integer, listBox As ListBox) As Long
    Dim y As Long
    Dim itemText As String
    Dim yString As String
    Dim startPos As Integer, commaPos As Integer
    itemText = ListBox.List(i)
    commaPos = InStr(itemText, ",")
    yString = VBA.Mid(itemText, commaPos + 1)
    y = Val(yString)
End Function

Sub transformation(polynomialDegree As Single, numberOfPoints As Integer, basePointListBox As ListBox, ListBox2 As ListBox)

    degreesOfFreedom = 2 * numberOfPoints - 2 
    If degreesOfFreedom < 0 Then
        MsgBox "Solution is not possible."
    End If


Dim xBasePoint As Single
Dim ynumb As Single
Dim x As String
Dim y As String

Dim xReferencePoint As Single
Dim yReferencePoint As Single
Dim Xpr
Dim Ypr
Dim k As Single
Dim l As Single

'dhlwsh pinakwn A kai b
ReDim b(1 To 2 * n)

ReDim xvect(1 To n) As Variant
ReDim yvect(1 To n) As Variant


' Populates k and l vectors. These vectors contain the powers 
' of each parameter of the polynomial (or of the paramters of the X, Y equations)
ReDim kVector(0 To numberOfPoints-1)
ReDim lVector(0 To numberOfPoints-1)
If index = "Bilinear" Then 'GIA DIGRAMMIKO
    kVector = Array(0, 1, 0, 1)
    lVector = Array(0, 0, 1, 1)
Else
    For k = 0 To polynomialDegree
        For l = 0 To k
            kVector(k) = k - l
            lVector(k) = l
        Next l
    Next k
End If


'dhmioyrgei 2 dianysmata me tis yimes twn xi kai yi
'gia ton algori8mo twn stoixeiwn toy A

For i = 0 To basePointListBox.ListCount - 1
    ' get x, y of base point
    xBasePoint = xForIndexFromListBox(i, basePointListBox)
    yBasePoint  = yForIndexFromListBox(i, basePointListBox)

    ' get x, y of reference point
    xReferencePoint = xForIndexFromListBox(i, referencePointListBox)
    yReferencePoint = yForIndexFromListBox(i, referencePointListBox)

    'CREATE b
    b(i + 1) = xReferencePoint
    b(i + n + 1) = yReferencePoint

    'CREATE A
    xvect(i + 1) = xBasePoint
    yvect(i + 1) = yBasePoint
Next i

If index = "Similarity" Then
'Dim a2dim As Integer
'a2dim = 2 * numberOfPoints
ReDim A(1 To 2 * n, 1 To 2 * numberOfPoints) As Variant
'ReDim A(2 * n, a2dim)  'As Variant
Call A_OMOIOTHTAS(numberOfPoints, A, n)
Else
    ReDim amikVectoros(1 To n, 1 To numberOfPoints) As Variant
    'yplogigei ena tmhma tou PINAKA SXEDIASMOU, to pinaka amikVectoros
    For i = 1 To n
        For j = 1 To UBound(kVector)
        amikVectoros(i, j) = xvect(i) ^ kVector(j) * yvect(i) ^ lVector(j)
        ''''MsgBox "j = " & j & " kVector(j) " & kVector(j) & "   lVector(j) " & lVector(j)
        Next j
    Next i
    'yplogigei ton PINAKA SXEDIASMOU A
    ReDim A(1 To 2 * n, 1 To 2 * numberOfPoints) As Variant
    For i = 1 To 2 * n
        For j = 1 To 2 * numberOfPoints
        If i <= n And j <= numberOfPoints Then
        A(i, j) = amikVectoros(i, j)
        Else
        If (n + 1) <= i And (numberOfPoints + 1) <= j Then
        A(i, j) = amikVectoros(i - n, j - numberOfPoints)
        Else: A(i, j) = 0
        End If
        End If
        Next j
    Next i

    'typwnei ton A
    Open "c:\temp\pinakasA.txt" For Output As #1
    For i = 1 To 2 * n
        For j = 1 To 2 * numberOfPoints
        Print #1, A(i, j),
        Next j
        Print #1,    ' Print blank line to file.
    Next i
    Close #1
End If

'typwnei ton b
Open "c:\temp\pinakasb.txt" For Output As #3
For i = 1 To 2 * n
    Print #3, b(i)
Next i
Close #3

'dhmioyrgei dokimastika ton P
'pinaka varwn
ReDim P(1 To 2 * n, 1 To 2 * n) As Variant
For i = 1 To 2 * n
    For j = 1 To 2 * n
    If i = j Then
    P(i, j) = 1
    Else
    P(i, j) = 0
    End If
    Next j
Next i

'TRANSPOSE MATRIX
ReDim Transpose_A(1 To 2 * numberOfPoints, 1 To 2 * n) As Variant
Call TransposeMatrix(numberOfPoints, A, n)

'Calculates the product [A]*[A-1] which must be always equal to the Singular Matrix [I]
'The same result must also come up for the product: [A-1]*[A]=[I]
'You can try it using: Matrix_Mult(k, m) = Matrix_Mult(k, m) + Inverse_Matrix(L, m) * Matrix_A(k, L)

'MULTIPLICATION TRANSPOSE_A * P (=AT*P)
ReDim ATP(1 To 2 * numberOfPoints, 1 To 2 * n)
For k = 1 To 2 * numberOfPoints
    For m = 1 To 2 * n
        ATP(k, m) = ATP(k, m) + Transpose_A(k, m) * P(m, m)
    Next m
Next k


'PINAKES KANONIKWN E3ISWSEWN (N KAI u)
'N = TRANSPOSE_A * P * A
ReDim Nmat(1 To 2 * numberOfPoints, 1 To 2 * numberOfPoints)
For k = 1 To 2 * numberOfPoints
    For m = 1 To 2 * numberOfPoints
        For l = 1 To 2 * n
            Nmat(k, m) = Nmat(k, m) + ATP(k, l) * A(l, m)
        Next l
    Next m
Next k
'typwnei ton N
Open "c:\temp\Nmat.txt" For Output As #12
For i = 1 To 2 * numberOfPoints
    For j = 1 To 2 * numberOfPoints
    Print #12, Nmat(i, j),
    Next j
    Print #12,    ' Print blank line to file.
Next i
Close #12

ReDim u(1 To 2 * numberOfPoints) As Variant
For k = 1 To 2 * numberOfPoints
        For l = 1 To 2 * n
            u(k) = u(k) + ATP(k, l) * b(l)
        Next l
Next k
'typwnei ton u
Open "c:\temp\u.txt" For Output As #13
For i = 1 To 2 * numberOfPoints
    Print #13, u(i),
Next i
Close #13

ReDim inverse_N(1 To 2 * numberOfPoints, 1 To 2 * numberOfPoints) As Variant
Call Inverse_Table(numberOfPoints, Nmat) ', inverse_N)

Open "c:\temp\Inverse_N.txt" For Output As #14
For i = 1 To 2 * numberOfPoints
    For j = 1 To 2 * numberOfPoints
    
    Print #14, inverse_N(i, j),
    Next j
    Print #14,    ' Print blank line to file.
Next i
Close #14

ReDim xekt(1 To 2 * numberOfPoints)
For k = 1 To 2 * numberOfPoints
        For l = 1 To 2 * numberOfPoints
            xekt(k) = xekt(k) + inverse_N(k, l) * u(l)
        Next l
Next k
'typwnei ton xekt (ektimiseis parametrwn)
Open "c:\temp\xekt.txt" For Output As #15
For i = 1 To 2 * numberOfPoints
    Print #15, xekt(i),
Next i
Close #15

ReDim AX_mat(1 To 2 * n)
For k = 1 To 2 * n
        For l = 1 To 2 * numberOfPoints
            AX_mat(k) = AX_mat(k) + A(k, l) * xekt(l)
        Next l
Next k

ReDim v(1 To 2 * n)
For i = 1 To 2 * n
    v(i) = b(i) - AX_mat(i)
Next i

If degreesOfFreedom = 0 Then
MsgBox "Solution without least square method application."
Else
'Dim sigma_aposteriori As Double
For i = 1 To 2 * n
  stoixeio = v(i) ^ 2
  Sstoixeio = Sstoixeio + stoixeio
Next i
sigma_aposteriori = Sstoixeio / degreesOfFreedom
F_test = sigma_aposteriori / apriori_s
'MsgBox F_test

Call FTEST(degreesOfFreedom, F_test)
End If
End If

Call residual(xvect, yvect, xekt, n)

End Sub
